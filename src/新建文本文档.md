<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Markdown è½¬ HTML å·¥å…·</title>
    <style>
      /* ç®€å•çš„ CSS ç¾åŒ– */
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        background-color: #f6f8fa;
        color: #333;
      }
      h1 { margin-bottom: 30px; font-size: 24px; }
      .btn-container { display: flex; flex-direction: column; gap: 15px; width: 80%; max-width: 300px; }
      button {
        padding: 15px;
        font-size: 16px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.2s;
        font-weight: bold;
      }
      .btn-primary { background-color: #007bff; color: white; }
      .btn-primary:hover { background-color: #0056b3; }
      .btn-secondary { background-color: #28a745; color: white; }
      .btn-secondary:hover { background-color: #1e7e34; }
      #status { margin-top: 20px; font-size: 14px; color: #666; text-align: center; white-space: pre-wrap;}
    </style>
  </head>
  <body>
    <h1>Markdown è¡¨æ ¼è½¬ HTML</h1>
    
    <div class="btn-container">
      <button class="btn-primary" id="btn-file">ğŸ“ é€‰æ‹© Markdown æ–‡ä»¶</button>
      <button class="btn-secondary" id="btn-clipboard">ğŸ“‹ ä»å‰ªè´´æ¿è¯»å–å¹¶ä¿å­˜</button>
    </div>

    <div id="status"></div>

    <script type="module">

      // ä¿®æ”¹å (Tauri v2 æ­£ç¡®å†™æ³•)
      import { open, save } from '@tauri-apps/plugin-dialog';
      import { readTextFile, writeTextFile } from '@tauri-apps/plugin-fs';
      import { readText } from '@tauri-apps/plugin-clipboard-manager';
      import { invoke } from '@tauri-apps/api/core'; // è¿™æ˜¯ä¸€ä¸ªåŸºç¡€æ ¸å¿ƒåŒ…

      const statusDiv = document.getElementById('status');

      // ==========================================
      // æ ¸å¿ƒé€»è¾‘ï¼šç”¨ JS æ›¿ä»£ Python Pandas
      // ==========================================
      function convertMdToHtml(mdContent, fileNameBase) {
        try {
          // 1. æ‹†åˆ†è¡Œå¹¶æ¸…æ´—
          let lines = mdContent.split('\n');
          // ç§»é™¤ Markdown åˆ†éš”çº¿ (åŒ…å« --- çš„è¡Œ)
          lines = lines.filter(line => !line.includes('---') && line.trim() !== '');

          if (lines.length < 2) throw new Error("å†…å®¹ä¼¼ä¹ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®");

          // 2. è§£æè¡¨å¤´
          // å‡è®¾è¡¨æ ¼ä»¥ | åˆ†éš”
          const headers = lines[0].split('|').map(h => h.trim()).filter(h => h !== '');
          
          // æ‰¾åˆ°æˆ‘ä»¬å…³å¿ƒçš„åˆ—çš„ç´¢å¼•
          const targetCols = ['mainTaskId', 'time', 'userId', 'output'];
          const colIndices = {};
          headers.forEach((h, index) => {
            if (targetCols.includes(h)) colIndices[h] = index;
          });

          // 3. è§£ææ•°æ®è¡Œ
          const dataRows = [];
          // ä»ç¬¬1è¡Œå¼€å§‹ï¼ˆç¬¬0è¡Œæ˜¯è¡¨å¤´ï¼‰
          for (let i = 1; i < lines.length; i++) {
            const cells = lines[i].split('|').map(c => c.trim());
            // å¤„ç† split '|' åé¦–å°¾å¯èƒ½äº§ç”Ÿçš„ç©ºå­—ç¬¦ä¸²
            // æ¯”å¦‚ "| a | b |" splitåæ˜¯ ["", "a", "b", ""]
            // ç®€å•çš„å¤„ç†æ–¹å¼æ˜¯å»æ‰é¦–å°¾ç©ºé¡¹ï¼Œä½†è¿™å–å†³äº md çš„æ ¼å¼ï¼Œè¿™é‡Œåšä¸€ä¸ªç®€å•çš„å¯¹å…¶å°è¯•
            const cleanCells = cells.filter(c => c !== '' || c === ' '); // ä¿ç•™ä¸­é—´çš„ç©ºå†…å®¹ä½†å»é™¤çº¯æ ¼å¼é€ æˆçš„ç©º
            
            // å®é™…ä¸Š markdown è¡¨æ ¼æ¯”è¾ƒä¹±ï¼Œæ›´ç¨³å¦¥çš„æ˜¯å–å¯¹åº”ç´¢å¼•ã€‚
            // é‡æ–°å¯¹å…¶ï¼šé€šå¸¸ split('|') åï¼Œå¦‚æœè¡Œé¦–æœ‰ |ï¼Œç¬¬0ä¸ªæ˜¯ç©ºã€‚
            const rowData = {};
            let maxImages = 0;
            
            // ç®€å•çš„ CSV è§£æç­–ç•¥
            const rawCells = lines[i].split('|');
            // å»é™¤é¦–å°¾å¯èƒ½çš„ç©ºå…ƒç´  (Markdownè¡¨æ ¼ä¸¤è¾¹é€šå¸¸æœ‰ |)
            if(rawCells[0].trim() === '') rawCells.shift();
            if(rawCells[rawCells.length-1].trim() === '') rawCells.pop();

            targetCols.forEach(col => {
               if (colIndices[col] !== undefined && rawCells[colIndices[col]] !== undefined) {
                   rowData[col] = rawCells[colIndices[col]].trim();
               } else {
                   rowData[col] = '';
               }
            });

            // 4. å¤„ç† Output å›¾ç‰‡ JSON
            rowData.images = [];
            if (rowData['output']) {
              try {
                // å°è¯•è§£æ JSON æ•°ç»„
                const parsed = JSON.parse(rowData['output']);
                if (Array.isArray(parsed)) {
                  rowData.images = parsed;
                }
              } catch (e) {
                // è§£æå¤±è´¥ï¼Œå¿½ç•¥
              }
            }
            dataRows.push(rowData);
          }

          // è®¡ç®—æœ€å¤§å›¾ç‰‡æ•°åˆ—æ•°ï¼Œç”¨äºç”Ÿæˆè¡¨å¤´
          const maxImgCount = Math.max(...dataRows.map(r => r.images.length), 0);

          // 5. ç”Ÿæˆ HTML è¡¨æ ¼
          let tableHtml = '<table><thead><tr>';
          // å›ºå®šåˆ—å¤´
          ['mainTaskId', 'time', 'userId'].forEach(col => {
             if (headers.includes(col)) tableHtml += `<th>${col}</th>`;
          });
          // å›¾ç‰‡åˆ—å¤´
          for (let k = 0; k < maxImgCount; k++) {
            tableHtml += `<th>Output Image ${k+1}</th>`;
          }
          tableHtml += '</tr></thead><tbody>';

          // æ•°æ®è¡Œ
          dataRows.forEach(row => {
            tableHtml += '<tr>';
            ['mainTaskId', 'time', 'userId'].forEach(col => {
              if (headers.includes(col)) tableHtml += `<td>${row[col] || ''}</td>`;
            });

            // å›¾ç‰‡åˆ—
            for (let k = 0; k < maxImgCount; k++) {
              const imgUrl = row.images[k];
              let cellContent = '';
              if (imgUrl) {
                // æ‡’åŠ è½½ + åŸå›¾é€»è¾‘ + Zoom æ ·å¼
                cellContent = `
                  <a href="${imgUrl}" target="_blank" title="ç‚¹å‡»æŸ¥çœ‹å¤§å›¾">
                    <img src="${imgUrl}" loading="lazy" width="150" 
                         style="border-radius:5px; border:1px solid #ccc; object-fit: cover; height: 150px; cursor: zoom-in;">
                  </a>
                `;
              }
              tableHtml += `<td>${cellContent}</td>`;
            }
            tableHtml += '</tr>';
          });
          tableHtml += '</tbody></table>';

          // 6. æœ€ç»ˆ HTML ç»“æ„
          const finalHtml = `
            <html>
            <head>
              <meta charset='utf-8'>
              <style>
                body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 20px; }
                table { border-collapse: collapse; width: 100%; }
                th { background-color: #f2f2f2; padding: 10px; text-align: left; border: 1px solid #ddd; position: sticky; top: 0; z-index: 10;}
                td { padding: 10px; border: 1px solid #ddd; vertical-align: top; }
                tr:nth-child(even) { background-color: #f9f9f9; }
                tr:hover { background-color: #f1f1f1; }
              </style>
            </head>
            <body>
              <h2>å¤„ç†ç»“æœ: ${fileNameBase}</h2>
              ${tableHtml}
            </body>
            </html>
          `;

          return finalHtml;
        } catch (error) {
          throw error;
        }
      }

      // ==========================================
      // äº‹ä»¶ç»‘å®š
      // ==========================================

      // åŠŸèƒ½ 1ï¼šé€‰æ‹©æ–‡ä»¶
      document.getElementById('btn-file').addEventListener('click', async () => {
        try {
          const selected = await open({
            filters: [{ name: 'Markdown', extensions: ['md', 'txt'] }]
          });

          if (selected) {
            statusDiv.textContent = "æ­£åœ¨å¤„ç†...";
            // è¯»å–æ–‡ä»¶
            const content = await readTextFile(selected);
            
            // è·å–è·¯å¾„ä¿¡æ¯
            // ç®€å•çš„è·¯å¾„å¤„ç† (Tauri path API ç¨æ˜¾å¤æ‚ï¼Œè¿™é‡Œç”¨ç®€å•çš„å­—ç¬¦ä¸²æ“ä½œï¼Œé€‚åˆå¤§å¤šæ•°æƒ…å†µ)
            // æ³¨æ„ï¼šè·¨å¹³å°è·¯å¾„åˆ†éš”ç¬¦ä¸åŒï¼Œä½†åœ¨JSä¸­å¤„ç†å­—ç¬¦ä¸²å³å¯
            const isWin = selected.includes('\\');
            const splitChar = isWin ? '\\' : '/';
            const fileName = selected.split(splitChar).pop();
            const fileBase = fileName.replace(/\.[^/.]+$/, "");
            const outputName = selected.replace(/\.[^/.]+$/, "") + "_output.html";

            // è½¬æ¢
            const html = convertMdToHtml(content, fileBase);

            // å†™å…¥
            await writeTextFile(outputName, html);

            statusDiv.textContent = "å®Œæˆï¼";
            await message(`æˆåŠŸï¼\nå·²ä¿å­˜è‡³: ${outputName}`);
            statusDiv.textContent = "";
          }
        } catch (err) {
          await message(`é”™è¯¯: ${err}`, { type: 'error' });
          statusDiv.textContent = "å‘ç”Ÿé”™è¯¯";
        }
      });

      // åŠŸèƒ½ 2ï¼šå‰ªè´´æ¿
      document.getElementById('btn-clipboard').addEventListener('click', async () => {
        try {
          const content = await readText();
          if (!content || !content.trim()) {
            await message('å‰ªè´´æ¿ä¸ºç©ºï¼', { type: 'warning' });
            return;
          }

          // è¯¢é—®ä¿å­˜ä½ç½® (ä¿å­˜ .md)
          const savePath = await save({
            filters: [{ name: 'Markdown', extensions: ['md'] }],
            defaultPath: 'clipboard_data.md'
          });

          if (savePath) {
            statusDiv.textContent = "æ­£åœ¨å¤„ç†...";
            // 1. ä¿å­˜ MD
            await writeTextFile(savePath, content);

            // 2. è½¬æ¢å¹¶ä¿å­˜ HTML
            const isWin = savePath.includes('\\');
            const splitChar = isWin ? '\\' : '/';
            const fileName = savePath.split(splitChar).pop();
            const fileBase = fileName.replace(/\.[^/.]+$/, "");
            const outputName = savePath.replace(/\.[^/.]+$/, "") + "_output.html";

            const html = convertMdToHtml(content, fileBase);
            await writeTextFile(outputName, html);

            statusDiv.textContent = "å®Œæˆï¼";
            await message(`æˆåŠŸï¼\nå·²ä¿å­˜è‡³: ${outputName}`);
            statusDiv.textContent = "";
          }

        } catch (err) {
          await message(`é”™è¯¯: ${err}`, { type: 'error' });
          statusDiv.textContent = "å‘ç”Ÿé”™è¯¯";
        }
      });
    </script>
  </body>
</html>